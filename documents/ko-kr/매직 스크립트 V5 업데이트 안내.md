# 주요 변경사항 (2020. 02. 13. 업데이트)
* 파서 교체
    * 완전히 새로워진 문법/구문
    * 컴파일된 코드 생성
    * 더 빠른 코드 실행속도
    * 가독성 개선
    * `함수` 개념 추가
    * `지역 변수` 개념 추가
    * `전역 변수` 개념 추가
    * `자료형` 개념 추가
* `UTF-8 (BOM 없음)` 인코딩 적용
* `goto`를 제외한 모든 명령어 삭제
* `label` 및 `local` 키워드 추가
* `+ operator` 및 `- operator`, `* operator`, `/ operator`, `% operator` 추가
* `& operator` 및 `| operator`, `^ operator` 추가
* `if` 및 `else if`, `else` 추가
* `== operator` 및 `!= operator`, `>= operator`, `<= operator`, `> operator`, `< operator` 추가
* `int` 및 `long`, `float`, `double`, `string` 자료형 추가
* `= operator` 추가
* `global` 및 `this` 키워드 추가

### Before
```
push 0;
.main;
cmp %0, 100;
jnl .l1;
add %0, 1;
goto .main;
.l1;
pop;
```

### After
```
void __main():
  local(int) a
  a = 0
  
  label(main):
  
  if (a < 100)
  {
    a = a + 1
    goto main
  }
  
  ret
```

# 스크립트 단방향 업그레이드
**'매직 스크립트 V5'부터 업그레이드되지 않은 스크립트는 지원되지 않습니다**   


## 라벨 
기존에는 콤마(.)로 시작하여 세미콜론(;)으로 끝나는 문자열을 식별자로 사용하였으나, 이제는 label이라는 키워드와 함께 사용되어야 하며 콜론(:)으로 끝나야합니다.


#### Before
```
.label_0;
.label_1;
.my_label;
```

#### After 
```
label(.label_0):
label(.label_1):
label(.my_label):
```



## Cmp ... Jump
`cmp` 및 `je`, `jne`, `jl`, `jg`, `jge/jnl`, `jle/jng` 명령어는 이제 단일 'if' 문으로 대체됩니다  
주의: 분기 명령어(`cmp`제외 j로 시작하는 명령어들)를 `if`로 번역할 때에는 반대의 의미를 갖는 연산자를 사용해야합니다  

| Before | After |
| :---- | :----- |
| cmp `x`, `y` | if (`x` `<연산자>` `y`) |

| 분기 명령어 | 뜻이 같은 연산자 | 실행 결과가 같은 연산자 |
| :--------: | :------: | :----: |
| je | `==` | `!=` |
| jne | `!=` | `==` |
| jl | `<` | `>=` |
| jg | `>` | `<=` |
| jge/jnl | `>=` | `<` |
| jle/jng | `<=` | `>` |

#### Before
```
cmp 10, 20;
jne .end_if;
(somecode)
.end_if;
```

#### After
```
if (10 == 20)
{
  (somecode)
}
```



## 산술 연산자
`add` 및 `sub`, `mul`, `div`, and `mod` 명령어들은 이제 `산술 연산자`로 대체됩니다.  


| 명령어 | 연산자 |
| :-----: | :------: |
| add | '+' |
| sub | '-' |
| mul | '*' |
| div | '/' |
| mod | '%' |

#### Before
```
add %0, 100
```

#### After
```
x = x + 100
```




## 비트 연산자
`and` 및 `or`, `xor` 명령어들은 이제 `비트 연산자`로 대체됩니다.  

| 명령어 | 연산자 |
| :-----: | :------: |
| AND | '&' |
| OR | '|' |
| XOR | '^' |





## 실행 우선 순위
기본 파서는 개발자가 귀찮은 관계로 실행 우선 순위를 고려하지 않도록 디자인되었습니다.  
항상 왼쪽의 연산자가 먼저 실행됩니다.  

### 예시
```
a + b가 먼저 계산되고 그 결과 값에 2를 곱함

a + b * 2
```





## 자료형
### 상수
이제 모든 상수 값은 자료형을 명시해야합니다.  

| 표현 | 자료형 | 범위 |
| :--------: | :-------: | :---- |
| 100 | `int` | `-2147483648` ~ `2147483647` |
| 100L | `long` | `-9223372036854775808` ~ `9223372036854775807` |
| 100f | `float` |  `-3.4E+38` ~ `3.4E+38` (epsilon: `3.4E-38`) |
| 100d | `double` | `-1.79E+308` ~ `1.79E+308` (epsilon: `1.79E-308`) |
| "100" | `string` | `utf-8` |





## 함수
### 기본
```
void MyFirstFunc():
  <...do something...>
  ret
```

### 반환 & 매개 변수
반환은 자료형만 명시해주고, 매개 변수는 `자료형`과 `이름`이 한 쌍으로 구성되어야합니다  
```
int MyFirstFunc(int a, int b):
   a + b
   ret
```

### 지역 변수 선언
**지역 변수 이름은 매개 변수 이름과 같을 수 없습니다**  

#### 표현
```
local(<자료형>) <이름>
```

### 함수 호출
함수 내에서 다른 함수를 호출 할 수 있습니다.  
`<값>`은 지역 변수, 매개 변수, 전역 변수 또는 상수 중 하나입니다.  

```
호출하려는 함수가 매개 변수를 가지고 있음:
<함수명>(<값>,...)

호출하려는 함수가 매개 변수를 가지고있지 않음:
<함수명>()
```

만약, 호출하려는 함수의 반환 자료형이 `void`가 아닌 경우 지역 변수에 반환 값을 저장할 수 있습니다.  
```
local(<반환 자료형>) <변수명>

<변수명> = <함수명>(<값>,...)
```

### `global` & `this` 키워드
기본적으로 함수 외부에서 전역 변수를 선언할 때 사용됩니다.  
선언된 전역 변수를 사용할 때에는 `this`키워드와 함께 사용합니다.  

```
global int a

int func(int a):
  this.a + a
  ret
```


