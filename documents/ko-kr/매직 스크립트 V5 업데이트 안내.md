# 주요 변경사항 (2020. 02. 13.)
* 파서 교체
    * 완전히 새로워진 문법/구문
    * 컴파일된 코드 생성
    * 더 빠른 코드 실행속도
    * 가독성 개선
    * `함수` 개념 추가
    * `지역 변수` 개념 추가
    * `전역 변수` 개념 추가
    * `자료형` 개념 추가
* `UTF-8 (BOM 없음)` 인코딩 적용
* `goto`를 제외한 모든 명령어 삭제
* `label` 및 `local` 키워드 추가
* `+ operator` 및 `- operator`, `* operator`, `/ operator`, `% operator` 추가
* `& operator` 및 `| operator`, `^ operator` 추가
* `if` 및 `else if`, `else` 추가
* `== operator` 및 `!= operator`, `>= operator`, `<= operator`, `> operator`, `< operator` 추가
* `int` 및 `long`, `float`, `double`, `string` 자료형 추가
* `= operator` 추가
* `global` 및 `this` 키워드 추가

# 추가 변경사항 (2020. 03. 01. 최종)
* 모든 `.oni.script` 에 대해 `UTF-8 (BOM 없음)` 인코딩 적용
* 모든 `.txt`에 대해 C# 기본 인코딩 적용
* 이전 명령어들은 `marg` 에 합쳐짐
* `<< operator` 및 `>> operator` 추가
* `for` 및 `foreach` 추가
* `bool` 및 `byte`, `sbyte`, `ushort`, `short` 자료형 추가
* `marg` 및 `entities`, `entity`, `levels`, `level` **특수 자료형** 추가
* `tmain` 및 `tcmain`, `tgmain`, `rpmain`, `rbmain` **특수 함수** 지원
* 배열 개념 추가
   * `[] operator` 추가
* `bool[]` 자료형 지원
* 단항 연산자 `++ operator` 및 `-- operator` 지원
* 인스턴스의 함수 호출, 필드 액세스 지원
   * `:: operator` 추가

### Before
```
push 0;
.main;
cmp %0, 100;
jnl .l1;
add %0, 1;
goto .main;
.l1;
pop;
```

### After
```
void __main():
  local(int) a
  a = 0
  
  label(main):
  
  if (a < 100)
  {
    a = a + 1
    goto main
  }
  
  ret
```

# 스크립트 단방향 업그레이드
**'매직 스크립트 V5'부터 업그레이드되지 않은 스크립트는 지원되지 않습니다**   


## 라벨 
기존에는 콤마(.)로 시작하여 세미콜론(;)으로 끝나는 문자열을 식별자로 사용하였으나, 이제는 label이라는 키워드와 함께 사용되어야 하며 콜론(:)으로 끝나야합니다.


#### Before
```
.label_0;
.label_1;
.my_label;
```

#### After 
```
label(.label_0):
label(.label_1):
label(.my_label):
```



## Cmp ... Jump
`cmp` 및 `je`, `jne`, `jl`, `jg`, `jge/jnl`, `jle/jng` 명령어는 이제 단일 'if' 문으로 대체됩니다  
주의: 분기 명령어(`cmp`제외 j로 시작하는 명령어들)를 `if`로 번역할 때에는 반대의 의미를 갖는 연산자를 사용해야합니다  

| Before | After |
| :---- | :----- |
| cmp `x`, `y` | if (`x` `<연산자>` `y`) |

| 분기 명령어 | 뜻이 같은 연산자 | 실행 결과가 같은 연산자 |
| :--------: | :------: | :----: |
| je | `==` | `!=` |
| jne | `!=` | `==` |
| jl | `<` | `>=` |
| jg | `>` | `<=` |
| jge/jnl | `>=` | `<` |
| jle/jng | `<=` | `>` |

#### Before
```
cmp 10, 20;
jne .end_if;
(somecode)
.end_if;
```

#### After
```
if (10 == 20)
{
  (somecode)
}
```



## 산술 연산자
`add` 및 `sub`, `mul`, `div`, and `mod` 명령어들은 이제 `산술 연산자`로 대체됩니다.  


| 명령어 | 연산자 |
| :-----: | :------: |
| add | '+' |
| sub | '-' |
| mul | '*' |
| div | '/' |
| mod | '%' |

#### Before
```
add %0, 100
```

#### After
```
x = x + 100
```




## 비트 연산자
`and` 및 `or`, `xor` 명령어들은 이제 `비트 연산자`로 대체됩니다.  
`<<` 및 `>>` 비트 연산자가 추가되었습니다. (2020. 03. 01)

| 명령어 | 연산자 |
| :-----: | :------: |
| AND | '&' |
| OR | '|' |
| XOR | '^' |
| - | '<<' |
| - | '>>' |





## 실행 우선 순위
기본 파서는 개발자가 귀찮은 관계로 실행 우선 순위를 고려하지 않도록 디자인되었습니다.  
항상 왼쪽의 연산자가 먼저 실행됩니다.  

### 예시
```
a + b가 먼저 계산되고 그 결과 값에 2를 곱함

a + b * 2
```





## 자료형
### 상수
이제 모든 상수 값은 자료형을 명시해야합니다.  


`int`보다 작은 크기의 자료형에도 `int`형식을 사용해야하지만, 범위에 주의하시길 바랍니다.  
범위보다 크거나 작은 값은 표현되지 않거나 예기치못한 값을 표현할 수도 있습니다.  

`bool` 자료형은 `.true` 또는 `.false`로만 표현됩니다.  

| 표현 | 자료형 | 범위 |
| :--------: | :-------: | :---- |
| .true | `bool` | `.true` 또는 `.false` |
| 100 | `byte` | `0` ~ `255` |
| 100 | `sbyte` | `-128` ~ `127` |
| 100 | `ushort` | `0` ~ `65535` |
| 100 | `short` | `-32768` ~ `32767` |
| 100 | `int` | `-2147483648` ~ `2147483647` |
| 100L | `long` | `-9223372036854775808` ~ `9223372036854775807` |
| 100f | `float` |  `-3.4E+38` ~ `3.4E+38` (epsilon: `3.4E-38`) |
| 100d | `double` | `-1.79E+308` ~ `1.79E+308` (epsilon: `1.79E-308`) |
| "100" | `string` | `utf-8` |





## 함수
### 기본
```
void MyFirstFunc():
  <...do something...>
  ret
```

### 반환 & 매개 변수
반환은 자료형만 명시해주고, 매개 변수는 `자료형`과 `이름`이 한 쌍으로 구성되어야합니다  
```
int MyFirstFunc(int a, int b):
   a + b
   ret
```

### 지역 변수 선언
**지역 변수 이름은 매개 변수 이름과 같을 수 없습니다**  

#### 표현
```
local(<자료형>) <이름>
```

### 함수 호출
함수 내에서 다른 함수를 호출 할 수 있습니다.  
`<값>`은 지역 변수, 매개 변수, 전역 변수 또는 상수 중 하나입니다.  

```
호출하려는 함수가 매개 변수를 가지고 있음:
<함수명>(<값>,...)

호출하려는 함수가 매개 변수를 가지고있지 않음:
<함수명>()
```

만약, 호출하려는 함수의 반환 자료형이 `void`가 아닌 경우 지역 변수에 반환 값을 저장할 수 있습니다.  
```
local(<반환 자료형>) <변수명>

<변수명> = <함수명>(<값>,...)
```

### `global` & `this` 키워드
기본적으로 함수 외부에서 전역 변수를 선언할 때 사용됩니다.  
선언된 전역 변수를 사용할 때에는 `this`키워드와 함께 사용합니다.  

```
global int a

int func(int a):
  this.a + a
  ret
```



## 인스턴스의 함수 호출이나 필드 액세스
인스턴스 형식의 개체가 가지고있는 함수를 호출하거나, 선언되어있는 필드에 액세스하여 값을 읽을 수 있습니다.  

### 함수 호출
`::`연산자 뒤에 `()`가 따라붙으면 함수로 인식합니다.    
나머지는 일반 함수 호출과 동일합니다.  

```
void func(marg value):
   value::minions()
   ret
```

### 필드 액세스
`::`연산자 뒤에 `()`가 따라붙지 않으면 필드 액세스로 인식합니다.  


**경고** 아래 예제는 작동하지 않습니다.
```
void func(marg value):
   value::minions
   ret
```



## 반복문
### for
`선언` `조건` `지연된 실행` 3가지로 구성되는 반복문입니다.   

예:
```csharp
for (int a = 0; a < 4; a++)
{
   ...
}
```

#### 선언
여기서 for문에서 사용될 로컬 변수를 선언할 수 있습니다.  
같은 형식의 변수를 여러개 선언할 수 있습니다.  

```csharp
for (int a = 0, b = 0, c = 0, ...; ;)
```

#### 조건
`if`와 동일합니다.  
내부적으로도 `if` 파싱을 합니다.  


#### 지연된 실행
`for 본문`보다 늦게 실행되는 곳입니다.  


### foreach
일부 인스턴스 형식은 `foreach`반복을 지원합니다.  
`label`과 `if`를 사용했을때보다 비효율적인 코드를 만들지만, 높은 가독성을 얻을 수 있습니다.  


제공된 API 문서를 참고하여 해당 인스턴스의 `foreach`지원 여부와 반환 형식을 반드시 확인해보시길 바랍니다.  

```csharp
void func(marg value):
   foreach (entity a : value::minions())
   {
         
   }
   ret
```





## 배열
배열 개념이 추가되었습니다.   
형식에는 `[]` 접미사를 사용하며, `변수명[<숫자> 또는 <int형 값>]`으로 사용합니다.   


```csharp
int get():
   1
   ret

void func(bool[] values):
   values[0] = .false
   values[get()] = .false
   ret
```





## ++, -- 단항 연산자
각각 `x = x + 1`, `x = x - 1`과 같은 역할을 합니다.  
실제로 더 효율적인 코드를 생성합니다.  



